---
layout: post
title: 'iOS: Cached Image Loaders'
tags:
- programming
- cocoa
- ios
date: 2010-09-29 21:50:00.000000000 -07:00
---
<p>Once you develop a media-rich project or two where you end up loading a bunch of smaller resources that may or may not be visible to the user at any given time (experiences like email, image galleries, and video games fit this description), you realize that having a dynamic cache of these resources is necessary to make the user's experience fluid. &nbsp;This is because available memory is smaller than the amount needed to keep all resources in memory at once, thus available for rendering at any time. &nbsp;However, you don't want an upper layer view (as in the MVC pattern) to manage or deal with the details of what does &amp; doesn't fit in memory: the abstraction it should deal with is to fetch and display the information. &nbsp;Additional complexity would be added when multiple views simultaneously manage these resources.<p /> Instead of thinking about keeping resources in memory, maybe we can simply fetch them every time they are needed by a view? &nbsp;Usually, these resources require some transformation before being displayed (decompression, color palette lookups, etc.) or they are very latent in their retrieval (stored on a DVD or on the internet behind a URL). &nbsp;Media rich applications typically need to support some form of animation or other dynamism with these resources - updating these resources in response to animation requires keeping them around in their transformed formats. &nbsp;When animations run every 16ms (at 60 frames per second), and resource retrieval and transformation can take hundreds of milliseconds, fetching every time a resource is needed is not a valid solution. <p /> So, a layer between views and resources is needed. &nbsp;This cache would be responsible for fetching resources as requested by views and transforming them to a usable state before handing them back to the view. &nbsp;Since the fetch and transformation is very latent, the cache remains in an indeterminate state between the first request and the completion of the fetch. &nbsp;Either the cache or view can decide what to do in this case by showing a placeholder resource, or waiting until the fetch is complete. &nbsp;Since it's a cache, there is also an eviction policy. &nbsp;This could be size-related, or time-related. &nbsp;For software programs that could cache their resources across sessions (such as web browsers), having the cache backed by storage is important. &nbsp;Most any software programmer should be familiar with these concepts.<p /> So why write a blog post about it? &nbsp;In iOS, Apple has provided a great many libraries to create media-rich applications: CoreAnimation, CoreImage, etc. &nbsp;But, a resource cache abstraction that is backed by application-owned storage is curiously missing. &nbsp;Of course, the community has filled the gap, but this is code that only really needs to be solved once as most applications in this style have very similar use cases. &nbsp;An especially interesting scenario is an application browsing a bunch of images downloaded from the Internet. &nbsp;This isn't narrowly scoped to photo album viewers, but includes apps that show box art or product photos, for example.<p /> <a href="http://davidgolightly.blogspot.com/2009/02/asynchronous-image-caching-with-iphone.html">This post</a> details a great solution in code.&nbsp; A commenter created <a href="http://github.com/rs/SDWebImage">this github repository</a> with a cohesive implementation that includes a UIImageView protocol category that helps you use this kind of caching transparently.&nbsp; If your app has anything to do with downloading lots of images, I highly recommend using this library or writing your own based on the details from the linked post.<p /> ~s</p>
